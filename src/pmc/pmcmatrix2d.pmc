#include "pla_matrix_types.h"

/* Resize the matrix internal storage to be able to hold a point at position
(x, y). The matrix grows but does not shrink. New spaces in the matrix
are initialized to 0.0. Parameters x and y are the indices that are trying
to be accessed, so we must resize the matrix to be able to accomodate those
indices. Notice that the matrix type is zero-indexed, so the size is one
plus the highest index that we need to access. */
static void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL row, INTVAL col)
{
    Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(self);
    const INTVAL old_cols = attrs->cols;
    const INTVAL old_rows = attrs->rows;
    const INTVAL new_cols = INDEX_MAX(old_cols, col + 1);
    const INTVAL new_rows = INDEX_MAX(old_rows, row + 1);
    const INTVAL newsize = new_cols * new_rows;
    PMC ** new_s = (PMC **)mem_sys_allocate_zeroed(newsize * sizeof (PMC *));
    PMC ** old_s = attrs->storage;
    const INTVAL min_cols = INDEX_MIN(old_cols, new_cols);
    const INTVAL min_rows = INDEX_MIN(old_rows, new_rows);
    INTVAL i, j;
    for (i = 0; i < min_cols; i++) {
        for (j = 0; j < min_rows; j++) {
            ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j) =
                ITEM_XY_ROWMAJOR(old_s, old_cols, old_rows, i, j);
        }
    }
    for (i = 0; i < new_cols; i++) {
        for (j = 0; j < new_rows; j++) {
            PMC * const v = ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j);
            if (v == NULL)
                ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j) = PMCNULL;
        }
    }
    attrs->storage = new_s;
    attrs->cols = new_cols;
    attrs->rows = new_rows;
    free(old_s);
}


pmclass PMCMatrix2D dynpmc auto_attrs provides matrix {
    ATTR PMC ** storage;
    ATTR INTVAL cols;
    ATTR INTVAL rows;

    VTABLE void init() {
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** const s = attrs->storage;
        if (s)
            mem_sys_free(s);
    }

    VTABLE void mark() {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** s = attrs->storage;
        const INTVAL rows = attrs->rows;
        const INTVAL cols = attrs->cols;
        const INTVAL size = rows * cols;
        INTVAL i;
        for (i = 0; i < size; i++) {
            PMC * const item = s[i];
            if (!PMC_IS_NULL(item))
                Parrot_gc_mark_PMC_alive(INTERP, item);
        }
    }

    VTABLE PMC * get_pmc_keyed(PMC * key) {
        INTVAL cols, rows, cols_size, rows_size;
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        "PMCMatrix2d: indices out of bounds");
        return ITEM_XY_ROWMAJOR(attrs->storage, cols_size, rows_size, cols, rows);
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL key) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        const INTVAL total_size = attrs->cols * attrs->rows;
        if (key >= total_size || key < 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        "PMCMatrix2D: indices out of bounds.");
        }
        return attrs->storage[key];
    }

    VTABLE INTVAL get_integer_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_integer(INTERP, item);
    }

    VTABLE FLOATVAL get_number_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_number(INTERP, item);
    }

    VTABLE STRING * get_string_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_string(INTERP, item);
    }

    VTABLE void set_pmc_keyed(PMC * key, PMC * value) {
        INTVAL cols, rows, cols_size, rows_size;
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size) {
            resize_matrix(INTERP, SELF, rows, cols);
            cols_size = attrs->cols;
            rows_size = attrs->rows;
        }
        ITEM_XY_ROWMAJOR(attrs->storage, cols_size, rows_size, cols, rows) = value;
    }

    VTABLE void set_integer_keyed(PMC * key, INTVAL value) {
        PMC * item = Parrot_pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_number_keyed(PMC * key, FLOATVAL value) {
        PMC * item = Parrot_pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_string_keyed(PMC * key, STRING * value) {
        PMC * item = Parrot_pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE STRING *get_string() {
        INTVAL rows, cols;
        STRING *pstr = Parrot_str_new(INTERP, "{\n", 2);
        STRING * const strend = Parrot_str_new(INTERP, "}", 1);
        STRING * const newline = Parrot_str_new(INTERP, "\n", 1);
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** const s = attrs->storage;
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;
        for (rows = 0; rows < rows_size; ++rows) {
            for (cols = 0; cols < cols_size; ++cols) {
                PMC * const item = ITEM_XY_ROWMAJOR(s, rows_size, cols_size, rows, cols);
                STRING * const index = Parrot_sprintf_c(INTERP, "\t[%d,%d] = ", rows, cols);
                STRING * str;
                if (PMC_IS_NULL(item))
                    str = CONST_STRING(INTERP, "<NULL>");
                else
                    str = VTABLE_get_string(INTERP, item);
                pstr = Parrot_str_append(INTERP, pstr, index);
                pstr = Parrot_str_append(INTERP, pstr, str);
                pstr = Parrot_str_append(INTERP, pstr, newline);
            }
        }
        pstr = Parrot_str_append(INTERP, pstr, strend);
        pstr = Parrot_str_append(INTERP, pstr, newline);
        return pstr;
    }

    VTABLE PMC * get_attr_str(STRING * idx) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "rows"))) {
            PMC * const rows = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, rows, attrs->rows);
            return rows;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "cols"))) {
            PMC * const cols = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, cols, attrs->cols);
            return cols;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "size"))) {
            PMC * const size = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, size, attrs->cols * attrs->rows);
            return size;
        }
        return PMCNULL;
    }

    VTABLE INTVAL is_equal(PMC *other) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        Parrot_PMCMatrix2D_attributes * const oattr = PARROT_PMCMATRIX2D(other);
        PMC ** s;
        INTVAL self_rows, self_cols, i, j, num = 0;

        if (other->vtable->base_type != SELF->vtable->base_type)
            return 0;

        self_rows = attrs->rows;
        self_cols = attrs->cols;

        if (self_rows != oattr->rows || self_cols != oattr->cols)
            return 0;
        s = attrs->storage;

        for (i = 0; i < self_rows; i++) {
            for (j = 0; j < self_cols; j++) {
                PMC * const ovalue = VTABLE_get_pmc_keyed_int(interp, other, num);
                PMC * const mvalue = ITEM_XY_ROWMAJOR(s, self_rows, self_cols, i, j);
                if (PMC_IS_NULL(mvalue)) {
                    if (!PMC_IS_NULL(ovalue))
                        return 0;
                }
                else {
                    if (!VTABLE_is_equal(INTERP, mvalue, ovalue))
                        return 0;
                }
                num++;
            }
        }
        return 1;
    }

    VTABLE PMC* clone() {
        PMC * const other = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        Parrot_PMCMatrix2D_attributes * const oattr = PARROT_PMCMATRIX2D(other);
        PMC ** s, ** o;
        INTVAL self_rows, self_cols, i, j, o_rows, o_cols;

        self_rows = attrs->rows;
        self_cols = attrs->cols;
        resize_matrix(INTERP, other, self_rows - 1, self_cols - 1);
        o_rows = oattr->rows;
        o_cols = oattr->cols;
        PARROT_ASSERT(self_rows == o_rows);
        PARROT_ASSERT(self_cols == o_cols);
        s = attrs->storage;
        o = oattr->storage;

        for (i = 0; i < self_rows; i++) {
            for (j = 0; j < self_cols; j++) {
                ITEM_XY_ROWMAJOR(s, self_rows, self_cols, i, j) =
                    ITEM_XY_ROWMAJOR(o, o_rows, o_cols, i, j);
            }
        }
        return other;
    }

    METHOD initialize_from_array(INTVAL rows_size, INTVAL cols_size, PMC * values) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** s;
        INTVAL self_rows, self_cols, i, j, num = 0;
        const INTVAL init_elems = VTABLE_elements(interp, values);

        resize_matrix(interp, SELF, rows_size - 1, cols_size - 1);
        self_rows = attrs->rows;
        self_cols = attrs->cols;
        s = attrs->storage;

        for (i = 0; i < cols_size; i++) {
            for (j = 0; j < rows_size; j++) {
                PMC * const value = VTABLE_get_pmc_keyed_int(interp, values, num);
                num++;
                ITEM_XY_ROWMAJOR(s, self_rows, self_cols, j, i) = value;
                if (num >= init_elems)
                    return;
            }
        }
    }

    METHOD resize(INTVAL rows, INTVAL cols) {
        resize_matrix(INTERP, SELF, rows - 1, cols - 1);
    }

    /*

=item fill()

Fill the matrix with a single value. if sizes are provided, fill to those
sizes, growing the matrix if needed.

=cut

*/

    METHOD fill(PMC * value,
                INTVAL x_size :optional, INTVAL has_rows_size :opt_flag,
                INTVAL y_size :optional, INTVAL has_cols_size :opt_flag
               ) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** s  = attrs->storage;
        INTVAL const curr_rows_size = attrs->rows;
        INTVAL const curr_cols_size = attrs->cols;
        INTVAL rows, cols;

        if (!has_rows_size)
            x_size = curr_rows_size;
        if (!has_cols_size)
            y_size = curr_cols_size;

        if ((has_rows_size && x_size > curr_rows_size) ||
            (has_cols_size && y_size > curr_cols_size)) {
            resize_matrix(INTERP, SELF, x_size - 1, y_size - 1);
            s = attrs->storage;
        }

        for (rows = 0; rows < x_size; ++rows) {
            for (cols = 0; cols < y_size; ++cols) {
                PMC * v;
                if (PMC_IS_NULL(value))
                    v = PMCNULL;
                else
                    v = VTABLE_clone(INTERP, value);
                ITEM_XY_ROWMAJOR(s, x_size, y_size, rows, cols) = v;
            }
        }
    }
}

