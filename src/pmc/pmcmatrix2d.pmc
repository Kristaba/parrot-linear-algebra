#include "pla_matrix_types.h"

/* Resize the matrix internal storage to be able to hold a point at position
(x, y). The matrix grows but does not shrink. New spaces in the matrix
are initialized to 0.0. Parameters x and y are the indices that are trying
to be accessed, so we must resize the matrix to be able to accomodate those
indices. Notice that the matrix type is zero-indexed, so the size is one
plus the highest index that we need to access. */
static void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL col, INTVAL row)
{
    Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(self);
    const INTVAL old_cols = attrs->cols;
    const INTVAL old_rows = attrs->rows;
    const INTVAL new_cols = INDEX_MAX(old_cols, col + 1);
    const INTVAL new_rows = INDEX_MAX(old_rows, row + 1);
    const INTVAL newsize = new_cols * new_rows;
    PMC ** new_s = (PMC **)mem_sys_allocate_zeroed(newsize * sizeof (PMC *));
    PMC ** old_s = attrs->storage;
    const INTVAL min_cols = INDEX_MIN(old_cols, new_cols);
    const INTVAL min_rows = INDEX_MIN(old_rows, new_rows);
    INTVAL i, j;
    for (i = 0; i < min_cols; i++) {
        for (j = 0; j < min_rows; j++) {
            ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j) =
                ITEM_XY_ROWMAJOR(old_s, old_cols, old_rows, i, j);
        }
    }
    attrs->storage = new_s;
    attrs->cols = new_cols;
    attrs->rows = new_rows;
    free(old_s);
}


pmclass PMCMatrix2D dynpmc auto_attrs provides matrix {
    ATTR PMC ** storage;
    ATTR INTVAL cols;
    ATTR INTVAL rows;

    VTABLE void init() {
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** const s = attrs->storage;
        if (s)
            mem_sys_free(s);
    }

    VTABLE void mark() {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** s = attrs->storage;
        const INTVAL rows = attrs->rows;
        const INTVAL cols = attrs->cols;
        const INTVAL size = rows * cols;
        INTVAL i;
        for (i = 0; i < size; i++) {
            PMC * const item = s[i];
            if (!PMC_IS_NULL(item))
                Parrot_gc_mark_PMC_alive(INTERP, item);
        }
    }
        
    VTABLE PMC * get_pmc_keyed(PMC * key) {
        INTVAL cols, rows, cols_size, rows_size;
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        "PMCMatrix2d: indices out of bounds");
        return ITEM_XY_ROWMAJOR(attrs->storage, cols_size, rows_size, cols, rows);
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL key) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        const INTVAL total_size = attrs->cols * attrs->rows;
        if (key >= total_size || key < 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        "PMCMatrix2D: indices out of bounds.");
        }
        return attrs->storage[key];
    }

    VTABLE INTVAL get_integer_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_integer(INTERP, item);
    }

    VTABLE FLOATVAL get_number_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_number(INTERP, item);
    }

    VTABLE STRING * get_string_keyed(PMC * key) {
        PMC * item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_string(INTERP, item);
    }

    VTABLE void set_pmc_keyed(PMC * key, PMC * value) {
        INTVAL cols, rows, cols_size, rows_size;
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size) {
            resize_matrix(INTERP, SELF, cols, rows);
            cols_size = attrs->cols;
            rows_size = attrs->rows;
        }
        ITEM_XY_ROWMAJOR(attrs->storage, cols_size, rows_size, cols, rows) = value;
    }

    VTABLE void set_integer_keyed(PMC * key, INTVAL value) {
        PMC * item = pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_number_keyed(PMC * key, FLOATVAL value) {
        PMC * item = pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_string_keyed(PMC * key, STRING * value) {
        PMC * item = pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE STRING *get_string() {
        INTVAL rows, cols;
        STRING *pstr = Parrot_str_new(INTERP, "{\n", 2);
        STRING * const strend = Parrot_str_new(INTERP, "}", 1);
        STRING * const newline = Parrot_str_new(INTERP, "\n", 1);
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** const s = attrs->storage;
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;
        for (cols = 0; cols < cols_size; ++cols) {
            for (rows = 0; rows < rows_size; ++rows) {
                PMC * const item = ITEM_XY_ROWMAJOR(s, rows_size, cols_size, rows, cols);
                STRING * const str = VTABLE_get_string(INTERP, item);
                STRING * const index = Parrot_sprintf_c(INTERP, "\t[%d,%d] = ", rows, cols);
                pstr = Parrot_str_append(INTERP, pstr, index);
                pstr = Parrot_str_append(INTERP, pstr, str);
                pstr = Parrot_str_append(INTERP, pstr, newline);
            }
        }
        pstr = Parrot_str_append(INTERP, pstr, strend);
        pstr = Parrot_str_append(INTERP, pstr, newline);
        return pstr;
    }
    
    VTABLE PMC * get_attr_str(STRING * idx) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "rows"))) {
            PMC * const rows = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, rows, attrs->rows);
            return rows;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "cols"))) {
            PMC * const cols = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, cols, attrs->cols);
            return cols;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "size"))) {
            PMC * const size = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, size, attrs->cols * attrs->rows);
            return size;
        }
        return PMCNULL;
    }

    METHOD initialize_from_array(INTVAL rows_size, INTVAL cols_size, PMC * values) {
        Parrot_PMCMatrix2D_attributes * const attrs = PARROT_PMCMATRIX2D(SELF);
        PMC ** s;
        INTVAL self_rows, self_cols, i, j, num = 0;
        const INTVAL init_elems = VTABLE_elements(interp, values);

        resize_matrix(interp, SELF, rows_size - 1, cols_size - 1);
        self_rows = attrs->rows;
        self_cols = attrs->cols;
        s = attrs->storage;

        for (i = 0; i < cols_size; i++) {
            for (j = 0; j < rows_size; j++) {
                PMC * const value = VTABLE_get_pmc_keyed_int(interp, values, num);
                num++;
                ITEM_XY_ROWMAJOR(s, self_rows, self_cols, j, i) = value;
                if (num >= init_elems)
                    return;
            }
        }
    }
}

