#include "pla_matrix_types.h"

#define ALLOCATE_STORAGE(s) (PMC **)mem_sys_allocate_zeroed(s * sizeof (PMC *))
#define PLATYPENAME "PMCMatrix2D"
#define DECLATTRS(p, a) Parrot_PMCMatrix2D_attributes * const (a) = \
    (Parrot_PMCMatrix2D_attributes *)((p)->data)

INTVAL __PLA_Type_PMCMatrix2D;

/* Resize the matrix internal storage to be able to hold a point at position
   (x, y). The matrix grows but does not shrink. New spaces in the matrix
   are initialized to 0.0. Parameters x and y are the indices that are trying
   to be accessed, so we must resize the matrix to be able to accomodate those
   indices. Notice that the matrix type is zero-indexed, so the size is one
   plus the highest index that we need to access.

   This function will not shrink the matrix, only grow it. After the call,
   the matrix will be at least large enough to hold an item at the given
   index. To shrink the matrix, use the get_block() method, or that
   algorithm. */
static void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL row, INTVAL col)
{
    DECLATTRS(self, attrs);
    /* Store the old values */
    const INTVAL old_rows = attrs->rows;
    const INTVAL old_cols = attrs->cols;
    PMC ** old_s = attrs->storage;

    /* rows and y are indices, not sizes. Resize the matrix to accomodate this
       new point without shrinking by taking the max. */
    const INTVAL new_rows = INDEX_MAX(old_rows, row + 1);
    const INTVAL new_cols = INDEX_MAX(old_cols, col + 1);
    const INTVAL newsize = new_rows * new_cols;
    PMC ** new_s = ALLOCATE_STORAGE(newsize);

    INTVAL i, j;
    for (i = 0; i < old_rows; i++) {
        for (j = 0; j < old_cols; j++) {
            ITEM_XY_ROWMAJOR(new_s, new_rows, new_cols, i, j) =
                ITEM_XY_ROWMAJOR(old_s, old_rows, old_cols, i, j);
        }
    }
    for (i = 0; i < new_cols; i++) {
        for (j = 0; j < new_rows; j++) {
            PMC * const v = ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j);
            if (v == NULL)
                ITEM_XY_ROWMAJOR(new_s, new_cols, new_rows, i, j) = PMCNULL;
        }
    }
    attrs->storage = new_s;
    attrs->rows = new_rows;
    attrs->cols = new_cols;
    if (old_s)
        mem_sys_free(old_s);
}



static void
init_from_pmc_array(PARROT_INTERP, PMC * self, INTVAL rows_size, INTVAL cols_size, PMC * values) {
    DECLATTRS(self, attrs);
    PMC ** s;
    INTVAL self_rows, self_cols, i, j, num = 0;
    const INTVAL init_elems = VTABLE_elements(interp, values);

    resize_matrix(interp, self, rows_size - 1, cols_size - 1);
    self_rows = attrs->rows;
    self_cols = attrs->cols;
    s = attrs->storage;

    for (i = 0; i < rows_size; i++) {
        for (j = 0; j < cols_size; j++) {
            PMC * const value = VTABLE_get_pmc_keyed_int(interp, values, num);
            ITEM_XY_ROWMAJOR(s, self_rows, self_cols, i, j) = value;
            num++;
            if (num >= init_elems)
                return;
        }
    }
}


pmclass PMCMatrix2D dynpmc auto_attrs provides matrix {
    ATTR PMC ** storage;
    ATTR INTVAL cols;
    ATTR INTVAL rows;
    ATTR INTVAL flags;

    void class_init() {
        __PLA_Type_PMCMatrix2D = entry;
    }

    VTABLE void init() {
        DECLATTRS(SELF, attrs);
        attrs->storage = NULL;
        attrs->rows = 0;
        attrs->cols = 0;
        attrs->flags = 0;
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        DECLATTRS(SELF, attrs);
        PMC ** const s = attrs->storage;
        if (s)
            mem_sys_free(s);
    }

    VTABLE void mark() {
        DECLATTRS(SELF, attrs);
        PMC ** s = attrs->storage;
        const INTVAL rows = attrs->rows;
        const INTVAL cols = attrs->cols;
        const INTVAL size = rows * cols;
        INTVAL i;
        for (i = 0; i < size; i++) {
            PMC * const item = s[i];
            if (!PMC_IS_NULL(item))
                Parrot_gc_mark_PMC_alive(INTERP, item);
        }
    }

/* Get VTABLEs */

    VTABLE PMC * get_pmc_keyed(PMC * key) {
        DECLATTRS(SELF, attrs);
        INTVAL cols, rows, cols_size, rows_size;
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        PLATYPENAME ": indices out of bounds");
        return ITEM_XY(attrs->storage, attrs->flags, rows_size, cols_size, rows, cols);
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL key) {
        DECLATTRS(SELF, attrs);
        const INTVAL total_size = attrs->cols * attrs->rows;
        if (key >= total_size || key < 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        PLATYPENAME ": indices out of bounds.");
        }
        return attrs->storage[key];
    }

    VTABLE INTVAL get_integer_keyed(PMC * key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_integer(INTERP, item);
    }

    VTABLE INTVAL get_integer_keyed_int(INTVAL key) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, key);
        return VTABLE_get_integer(INTERP, item);
    }

    VTABLE FLOATVAL get_number_keyed(PMC * key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_number(INTERP, item);
    }

    VTABLE FLOATVAL get_number_keyed_int(INTVAL key) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, key);
        return VTABLE_get_number(INTERP, item);
    }

    VTABLE STRING * get_string_keyed(PMC * key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_string(INTERP, item);
    }

    VTABLE STRING * get_string_keyed_int(INTVAL key) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, key);
        return VTABLE_get_string(INTERP, item);
    }

/* Set VTABLEs
TODO: Update all these to follow HLL mappings
*/

    VTABLE void set_pmc_keyed(PMC * key, PMC * value) {
        DECLATTRS(SELF, attrs);
        INTVAL cols, rows, cols_size, rows_size;
        cols_size = attrs->cols;
        rows_size = attrs->rows;
        GET_KEY_INDICES_ROWMAJOR(INTERP, key, rows, cols);
        if (cols >= cols_size || rows >= rows_size) {
            resize_matrix(INTERP, SELF, rows, cols);
            cols_size = attrs->cols;
            rows_size = attrs->rows;
        }
        ITEM_XY(attrs->storage, attrs->flags, rows_size, cols_size, rows, cols) = value;
    }

    VTABLE void set_pmc_keyed_int(INTVAL key, PMC * value) {
        DECLATTRS(SELF, attrs);
        const INTVAL total_size = attrs->cols * attrs->rows;
        if (key >= total_size || key < 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        PLATYPENAME ": indices out of bounds.");
        }
        attrs->storage[key] = value;
    }

    VTABLE void set_integer_keyed(PMC * key, INTVAL value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_integer_keyed_int(INTVAL key, INTVAL value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, item, value);
        VTABLE_set_pmc_keyed_int(INTERP, SELF, key, item);
    }

    VTABLE void set_number_keyed(PMC * key, FLOATVAL value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, value);
        VTABLE_set_pmc_keyed_int(INTERP, SELF, key, item);
    }

    VTABLE void set_string_keyed(PMC * key, STRING * value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, item, value);
        VTABLE_set_pmc_keyed(INTERP, SELF, key, item);
    }

    VTABLE void set_string_keyed_int(INTVAL key, STRING * value) {
        PMC * const item = Parrot_pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, item, value);
        VTABLE_set_pmc_keyed_int(INTERP, SELF, key, item);
    }

    VTABLE STRING *get_string() {
        DECLATTRS(SELF, attrs);
        INTVAL rows, cols;
        PMC * builder = Parrot_pmc_new(INTERP, enum_class_StringBuilder);
        STRING * const strend = Parrot_str_new(INTERP, "}", 1);
        STRING * const newline = Parrot_str_new(INTERP, "\n", 1);
        PMC ** const s = attrs->storage;
        const INTVAL flags = attrs->flags;
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;

        VTABLE_push_string(INTERP, builder, Parrot_str_new(INTERP, "{\n", 2));
        for (rows = 0; rows < rows_size; ++rows) {
            for (cols = 0; cols < cols_size; ++cols) {
                PMC * const item = ITEM_XY(s, flags, rows_size, cols_size, rows, cols);
                STRING * str;
                STRING * const index = Parrot_sprintf_c(INTERP, "\t[%d,%d] = ", rows, cols);
                if (PMC_IS_NULL(item))
                    str = CONST_STRING(INTERP, "<NULL>");
                else
                    str = VTABLE_get_string(INTERP, item);
                VTABLE_push_string(INTERP, builder, index);
                VTABLE_push_string(INTERP, builder, str);
                VTABLE_push_string(INTERP, builder, newline);
            }
        }
        VTABLE_push_string(INTERP, builder, strend);
        VTABLE_push_string(INTERP, builder, newline);
        return VTABLE_get_string(INTERP, builder);
    }

    /* TODO: Update this to account for transpositions */
    VTABLE PMC * get_attr_str(STRING * idx) {
        DECLATTRS(SELF, attrs);
        if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "rows"))) {
            PMC * const rows = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, rows, attrs->rows);
            return rows;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "cols"))) {
            PMC * const cols = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, cols, attrs->cols);
            return cols;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "size"))) {
            PMC * const size = Parrot_pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, size, attrs->cols * attrs->rows);
            return size;
        }
        return PMCNULL;
    }

    VTABLE INTVAL is_equal(PMC *other) {
        DECLATTRS(SELF, attrs);
        DECLATTRS(other, oattr);
        PMC ** const s = attrs->storage;
        PMC ** const o = oattr->storage;
        const INTVAL sflags = attrs->flags;
        const INTVAL oflags = oattr->flags;
        INTVAL self_rows = attrs->rows, self_cols = attrs->cols, i, j, num = 0;

        if (other->vtable->base_type != SELF->vtable->base_type)
            return 0;

        if (self_rows != oattr->rows || self_cols != oattr->cols)
            return 0;

        for (i = 0; i < self_rows; i++) {
            for (j = 0; j < self_cols; j++) {
                PMC * const ovalue = ITEM_XY(o, oflags, self_rows, self_cols, i, j);
                PMC * const mvalue = ITEM_XY(s, sflags, self_rows, self_cols, i, j);
                if (PMC_IS_NULL(mvalue)) {
                    if (!PMC_IS_NULL(ovalue))
                        return 0;
                }
                else if (PMC_IS_NULL(ovalue))
                    return 0;
                else if (!VTABLE_is_equal(INTERP, mvalue, ovalue))
                    return 0;
                num++;
            }
        }
        return 1;
    }

    VTABLE PMC* clone() {
        PMC * const other = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        DECLATTRS(SELF, attrs);
        DECLATTRS(other, oattr);
        PMC ** s, ** o;
        INTVAL self_rows, self_cols, i, j, o_rows, o_cols;

        self_rows = attrs->rows;
        self_cols = attrs->cols;
        resize_matrix(INTERP, other, self_rows - 1, self_cols - 1);
        o_rows = oattr->rows;
        o_cols = oattr->cols;
        PARROT_ASSERT(self_rows == o_rows);
        PARROT_ASSERT(self_cols == o_cols);
        s = attrs->storage;
        o = oattr->storage;

        for (i = 0; i < self_rows; i++) {
            for (j = 0; j < self_cols; j++) {
                ITEM_XY_ROWMAJOR(s, self_rows, self_cols, i, j) =
                    ITEM_XY_ROWMAJOR(o, o_rows, o_cols, i, j);
            }
        }
        oattr->flags = attrs->flags;
        return other;
    }

/*

=item* freeze

=item* thaw

=cut

*/

    VTABLE void freeze(PMC *info) {
        DECLATTRS(SELF, attrs);
        INTVAL const rows = attrs->rows;
        INTVAL const cols = attrs->cols;
        INTVAL const flags = attrs->flags;
        INTVAL i, j;
        PMC ** const s = attrs->storage;
        VTABLE_push_integer(INTERP, info, rows);
        VTABLE_push_integer(INTERP, info, cols);
        VTABLE_push_integer(INTERP, info, flags);
        for (i = 0; i < rows; i++) {
            for (j = 0; j < cols; j++) {
                PMC * const p = ITEM_XY(s, flags, rows, cols, i, j);
                VTABLE_push_pmc(INTERP, info, p);
            }
        }
    }

    VTABLE void thaw(PMC *info) {
        DECLATTRS(SELF, attrs);
        INTVAL const rows = VTABLE_shift_integer(INTERP, info);
        INTVAL const cols = VTABLE_shift_integer(INTERP, info);
        INTVAL const flags = VTABLE_shift_integer(INTERP, info);
        INTVAL i, j;
        PMC ** s;
        attrs->rows = 0;
        attrs->cols = 0;
        attrs->storage = NULL;
        attrs->flags = 0;
        resize_matrix(INTERP, SELF, rows - 1, cols - 1);
        s = attrs->storage;
        attrs->flags = flags;
        for (i = 0; i < rows; i++) {
            for (j = 0; j < cols; j++) {
                PMC * const p = VTABLE_shift_pmc(INTERP, info);
                ITEM_XY(s, flags, rows, cols, i, j) = p;
            }
        }
    }

    METHOD initialize_from_array(INTVAL rows_size, INTVAL cols_size, PMC *values) {
        init_from_pmc_array(INTERP, SELF, rows_size, cols_size, values);
    }

    METHOD initialize_from_args(INTVAL rows_size, INTVAL cols_size, PMC *values :slurpy) {
        init_from_pmc_array(INTERP, SELF, rows_size, cols_size, values);
    }

    METHOD resize(INTVAL rows, INTVAL cols) {
        resize_matrix(INTERP, SELF, rows - 1, cols - 1);
    }

/*

=item fill()

Fill the matrix with a single value. if sizes are provided, fill to those
sizes, growing the matrix if needed.

=cut

*/

    METHOD fill(PMC * value,
                INTVAL x_size :optional, INTVAL has_rows_size :opt_flag,
                INTVAL y_size :optional, INTVAL has_cols_size :opt_flag
               ) {
        DECLATTRS(SELF, attrs);
        PMC ** s  = attrs->storage;
        INTVAL const curr_rows_size = attrs->rows;
        INTVAL const curr_cols_size = attrs->cols;
        INTVAL rows, cols;

        if (!has_rows_size)
            x_size = curr_rows_size;
        if (!has_cols_size)
            y_size = curr_cols_size;

        if ((has_rows_size && x_size > curr_rows_size) ||
            (has_cols_size && y_size > curr_cols_size)) {
            resize_matrix(INTERP, SELF, x_size - 1, y_size - 1);
            s = attrs->storage;
        }

        for (rows = 0; rows < x_size; ++rows) {
            for (cols = 0; cols < y_size; ++cols) {
                PMC * v;
                if (PMC_IS_NULL(value))
                    v = PMCNULL;
                else
                    v = VTABLE_clone(INTERP, value);
                ITEM_XY_ROWMAJOR(s, x_size, y_size, rows, cols) = v;
            }
        }
    }

/*

=item item_at()

=cut

*/

    METHOD item_at(INTVAL row, INTVAL col,
        PMC * value :optional, INTVAL has_value :opt_flag) {
        DECLATTRS(SELF, attrs);
        const INTVAL rows = attrs->rows;
        const INTVAL cols = attrs->cols;
        const INTVAL flags = attrs->flags;
        PMC ** const s = attrs->storage;
        PMC * p;
        if (row >= rows || col >= cols || row < 0 || col < 0) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": indices out of bounds in item_at");
        }
        if (has_value)
            ITEM_XY(s, flags, rows, cols, row, col) = value;
        p = ITEM_XY(s, flags, rows, cols, row, col);
        RETURN(PMC * p);
    }

/*

=item transpose()

Transposes the matrix.

=cut

*/

    METHOD transpose() {
        DECLATTRS(SELF, attrs);
        INTVAL tmp = 0;
        INTVAL transposed = IS_TRANSPOSED(attrs->flags);

        SWAP_XY(attrs);

        if (transposed)
            attrs->flags -= FLAG_TRANSPOSED;
        else
            attrs->flags += FLAG_TRANSPOSED;
        transposed = !transposed;
        RETURN(INTVAL transposed);
    }

/*

=item mem_transpose()

Transposes the actual data storage of the matrix. More expensive up-front
than the transpose() method.

=cut

*/

    METHOD mem_transpose() {
        DECLATTRS(SELF, attrs);
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;
        const INTVAL newsize = rows_size * cols_size;
        PMC ** new_s = ALLOCATE_STORAGE(newsize);
        PMC ** old_s = attrs->storage;

        INTVAL i, j;
        for (i = 0; i < rows_size; i++) {
            for (j = 0; j < cols_size; j++) {
                ITEM_XY_ROWMAJOR(new_s, cols_size, rows_size, j, i) =
                    ITEM_XY_ROWMAJOR(old_s, rows_size, cols_size, i, j);
            }
        }
        attrs->storage = new_s;
        SWAP_XY(attrs);
        if (old_s)
            free(old_s);
    }

/*

=item iterate_function_inplace()

Calls a function for every element in the array, replacing the current
value with the return value of the called function.

=cut

*/

    METHOD iterate_function_inplace(PMC * func, PMC * args :slurpy) {
        DECLATTRS(SELF, attrs);
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;
        const INTVAL newsize = rows_size * cols_size;
        PMC ** old_s = attrs->storage;
        PMC ** new_s = ALLOCATE_STORAGE(newsize);
        INTVAL i, j;

        if (newsize == 0 || old_s == NULL)
            RETURN();

        for (i = 0; i < rows_size; i++) {
            for (j = 0; j < cols_size; j++) {
                PMC * const value = ITEM_XY_ROWMAJOR(old_s, rows_size, cols_size, i, j);
                PMC * result = PMCNULL;
                Parrot_ext_call(INTERP, func, "PPIIPf->P", SELF, value, i, j, args, &result);
                ITEM_XY_ROWMAJOR(new_s, rows_size, cols_size, i, j) = result;
            }
        }
        attrs->storage = new_s;
        if (old_s)
            free(old_s);
    }

    METHOD iterate_function_external(PMC * func, PMC * args :slurpy) {
        DECLATTRS(SELF, attrs);
        PMC * const new_matrix = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        DECLATTRS(new_matrix, new_attrs);
        const INTVAL rows_size = attrs->rows;
        const INTVAL cols_size = attrs->cols;
        const INTVAL newsize = rows_size * cols_size;
        const INTVAL flags = attrs->flags;
        PMC ** const self_s = attrs->storage;
        PMC ** new_s;
        INTVAL i, j;

        if (newsize == 0 || self_s == NULL)
            RETURN(PMC * new_matrix);

        resize_matrix(INTERP, new_matrix, rows_size - 1, cols_size - 1);
        new_s = new_attrs->storage;
        new_attrs->flags = flags;

        for (i = 0; i < rows_size; i++) {
            for (j = 0; j < cols_size; j++) {
                PMC * const value = ITEM_XY(self_s, flags, rows_size, cols_size, i, j);
                PMC * result = PMCNULL;
                Parrot_ext_call(INTERP, func, "PPIIPf->P", SELF, value, i, j, args, &result);
                ITEM_XY(new_s, flags, rows_size, cols_size, i, j) = result;
            }
        }
        RETURN(PMC * new_matrix);
    }

    METHOD get_block(INTVAL rows_idx, INTVAL cols_idx, INTVAL rows_size, INTVAL cols_size) {
        DECLATTRS(SELF, attrs);
        PMC ** const s = attrs->storage;
        const INTVAL rows = attrs->rows;
        const INTVAL cols = attrs->cols;
        INTVAL i, j;

        if ((rows < rows_idx + rows_size) || (cols < cols_idx + cols_size))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": Block boundaries exceed matrix size");
        if (rows_idx < 0 || cols_idx < 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": Can not get block at negative location");
        if (rows_size < 0 || cols_size < 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": Can not get block with negative size");
        else {
            PMC * const new_matrix = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
            Parrot_PMCMatrix2D_attributes * const new_attrs = PARROT_PMCMATRIX2D(new_matrix);
            PMC ** new_s;
            resize_matrix(INTERP, new_matrix, rows_size - 1, cols_size - 1);
            new_s = new_attrs->storage;
            for (i = 0; i < cols_size; i++) {
                for (j = 0; j < rows_size; j++) {
                    ITEM_XY_ROWMAJOR(new_s, rows_size, cols_size, j, i) =
                        ITEM_XY_ROWMAJOR(s, rows, cols, j + rows_idx, i + cols_idx);
                }
            }
            RETURN(PMC * new_matrix);
        }
    }

    METHOD set_block(INTVAL rows_idx, INTVAL cols_idx, PMC * blck) {
        DECLATTRS(SELF, self_attrs);
        DECLATTRS(blck, blck_attrs);
        PMC ** self_s = self_attrs->storage;
        PMC ** const blck_s = blck_attrs->storage;
        INTVAL self_rows = self_attrs->rows;
        INTVAL self_cols = self_attrs->cols;
        const INTVAL blck_rows = blck_attrs->rows;
        const INTVAL blck_cols = blck_attrs->cols;
        INTVAL i, j;

        if (rows_idx < 0 || cols_idx < 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": Can not set_block with negative indices");

        if (!VTABLE_does(INTERP, blck, CONST_STRING(interp, "matrix")))
            /* TODO: In this case, we should be able to do a .fill over the block
                     dimensions with VTABLE_get_number on the scalar value */
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                PLATYPENAME ": Can not set_block on a non-matrix value");

        if (blck_rows + rows_idx > self_rows || blck_cols + cols_idx > self_cols) {
            resize_matrix(INTERP, SELF, blck_rows + rows_idx - 1, blck_cols + cols_idx - 1);
            self_s = self_attrs->storage;
            self_rows = self_attrs->rows;
            self_cols = self_attrs->cols;
        }
        for (i = 0; i < blck_cols; i++) {
            for (j = 0; j < blck_rows; j++) {
                ITEM_XY_ROWMAJOR(self_s, self_rows, self_cols, j + rows_idx, i + cols_idx) =
                    ITEM_XY_ROWMAJOR(blck_s, blck_rows, blck_cols, j, i);
            }
        }
    }

/*

=item convert_to_number_matrix

Get a NumMatrix2D from the current matrix

=item convert_to_complex_matrix

Get a ComplexMatrix2D from the current matrix

=item convert_to_pmc_matrix

Get a PMCMatrix2D from the current matrix

=cut

*/

    METHOD convert_to_number_matrix() {
        DECLATTRS(SELF, attrs);
        PMC * const d = Parrot_pmc_new(INTERP, __PLA_Type_NumMatrix2D);
        const INTVAL totalsize = attrs->rows * attrs->cols;
        PMC * const meth = VTABLE_find_method(INTERP, d, CONST_STRING(INTERP, "resize"));
        INTVAL i;
        Parrot_ext_call(INTERP, meth, "PiII->", d, attrs->rows, attrs->cols);
        for (i = 0; i < totalsize; i++) {
            const FLOATVAL f = VTABLE_get_number_keyed_int(INTERP, SELF, i);
            VTABLE_set_number_keyed_int(INTERP, d, i, f);
        }
        RETURN(PMC * d);
    }

    METHOD convert_to_complex_matrix() {
        DECLATTRS(SELF, attrs);
        PMC * const d = Parrot_pmc_new(INTERP, __PLA_Type_ComplexMatrix2D);
        const INTVAL totalsize = attrs->rows * attrs->cols;
        PMC * const meth = VTABLE_find_method(INTERP, d, CONST_STRING(INTERP, "resize"));
        INTVAL i;
        Parrot_ext_call(INTERP, meth, "PiII->", d, attrs->rows, attrs->cols);
        for (i = 0; i < totalsize; i++) {
            PMC * const p = VTABLE_get_pmc_keyed_int(INTERP, SELF, i);
            VTABLE_set_pmc_keyed_int(INTERP, d, i, p);
        }
        RETURN(PMC * d);
    }

    METHOD convert_to_pmc_matrix() {
        PMC * const d = VTABLE_clone(INTERP, SELF);
        RETURN(PMC * d);
    }

}

