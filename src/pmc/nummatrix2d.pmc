#include <cblas.h>

#define GET_INDICES_FROM_KEY(i, k, x, y) \
    do { \
        (x) = VTABLE_get_integer((i), (k)); \
        (k) = VTABLE_shift_pmc((i), (k)); \
        (y) = VTABLE_get_integer((i), (k)); \
    } while(0);

#define INDEX_XY_ROWMAJOR(x_max, y_max, x, y) \
    (((x_max) * (x)) + (y))

#define INDEX_XY_COLMAJOR(x_max, y_max, x, y) \
    (((y_max) * (y)) + (x))

#define ITEM_XY_ROWMAJOR(s, x_max, y_max, x, y) \
    (s)[((x_max) * (x)) + (y)]

#define ITEM_XY_COLMAJOR(s, x_max, y_max, x, y) \
    (s)[((y_max) * (y)) + (x)]

#define INDEX_MIN(a, b) (((a) <= (b))?(a):(b))
#define INDEX_MAX(a, b) (((a) >= (b))?(a):(b))

/* Make the compiler happy. */
void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL x, INTVAL y);

/* Resize the matrix internal storage to be able to hold a point at position
   (x, y). The matrix grows but does not shrink. New spaces in the matrix
   are initialized to 0.0. Parameters x and y are the indices that are trying
   to be accessed, so we must resize the matrix to be able to accomodate those
   indices. Notice that the matrix type is zero-indexed, so the size is one
   plus the highest index that we need to access. */
void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL x, INTVAL y)
{
    Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(self);
    const INTVAL old_x = attrs->x;
    const INTVAL old_y = attrs->y;
    const INTVAL new_x = INDEX_MAX(old_x, x + 1);
    const INTVAL new_y = INDEX_MAX(old_y, y + 1);
    const INTVAL newsize = new_x * new_y;
    FLOATVAL * new_s = (FLOATVAL *)mem_sys_allocate_zeroed(newsize * sizeof (FLOATVAL));
    FLOATVAL * old_s = attrs->storage;
    const INTVAL min_x = INDEX_MIN(old_x, new_x);
    const INTVAL min_y = INDEX_MIN(old_y, new_y);
    INTVAL i, j;
    for (i = 0; i < min_x; i++) {
        for (j = 0; j < min_y; j++) {
            ITEM_XY_ROWMAJOR(new_s, new_x, new_y, i, j) =
                ITEM_XY_ROWMAJOR(old_s, old_x, old_y, i, j);
        }
    }
    attrs->storage = new_s;
    attrs->x = new_x;
    attrs->y = new_y;
    free(old_s);
}


pmclass NumMatrix2D dynpmc auto_attrs {
    ATTR FLOATVAL * storage;
    ATTR INTVAL x;
    ATTR INTVAL y;

    VTABLE void init() {
        Parrot_NumMatrix2D_attributes * const attrs =
            mem_allocate_zeroed_typed(Parrot_NumMatrix2D_attributes);

        attrs->x       = 0;
        attrs->y       = 0;
        attrs->storage = NULL;

        PMC_data(SELF) = attrs;

        PObj_custom_destroy_SET(SELF);
    }

    VTABLE FLOATVAL get_number_keyed(PMC * key) {
        INTVAL x, y, x_size, y_size;
        Parrot_NumMatrix2D_attributes * const attrs
          = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(SELF);
        x_size = attrs->x;
        y_size = attrs->y;
        GET_INDICES_FROM_KEY(INTERP, key, x, y);
        if (x >= x_size || y >= y_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "NumMatrix2d: indices out of bounds");
        return ITEM_XY_ROWMAJOR(attrs->storage, x_size, y_size, x, y);
    }

    VTABLE INTVAL get_integer_keyed(PMC * key) {
        return (INTVAL)VTABLE_get_number_keyed(INTERP, SELF, key);
    }

    VTABLE void set_number_keyed(PMC * key, FLOATVAL value) {
        INTVAL x, y, x_size, y_size;
        Parrot_NumMatrix2D_attributes * const attrs
            = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(SELF);
        x_size = attrs->x;
        y_size = attrs->y;
        GET_INDICES_FROM_KEY(INTERP, key, x, y);
        if (x >= x_size || y >= y_size) {
            resize_matrix(INTERP, SELF, x, y);
            x_size = attrs->x;
            y_size = attrs->y;
        }
        ITEM_XY_ROWMAJOR(attrs->storage, x_size, y_size, x, y) = value;
    }

    VTABLE void set_integer_keyed(PMC * key, INTVAL value) {
        VTABLE_set_number_keyed(INTERP, SELF, key, (FLOATVAL)value);
    }

    VTABLE STRING *get_string() {
        INTVAL x, y, x_size, y_size;
        char *str;
        STRING *pstr;
        Parrot_NumMatrix2D_attributes * const attrs
          = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(SELF);
        x_size = attrs->x;
        y_size = attrs->y;

        str = (char*) mem_sys_allocate_zeroed((8*x_size*y_size+1));

        for (x = 0; x < x_size; ++x) {
            for (y = 0; y < y_size; ++y) {
                int h = INDEX_XY_ROWMAJOR(x_size, y_size, x, y);
                snprintf(&(str[8*h]), 8, "%7.4f", attrs->storage[h]);
                str[8*h+7] = ' ';
            }
            str[8*(x+1)*y_size-1] = '\n';
        }

        str[8*x_size*y_size] = '\0';
        pstr = Parrot_str_new(INTERP, str, 0);
        mem_sys_free(str);

        return pstr;
    }

    MULTI PMC *add(NumMatrix2D* value, PMC* dest) {
        int i = 0;
        INTVAL x_size, y_size;
        Parrot_NumMatrix2D_attributes * const selfattr
          = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * const valattr
          = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(value);
        Parrot_NumMatrix2D_attributes * destattr;

        x_size = selfattr->x;
        y_size = selfattr->y;

        if (x_size != valattr->x || y_size != valattr->y) {
            /* XXX: Throw a better exception. */
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
              "NumMatrix2D: Matrix dimensions must match in add.");
        }

        /* TODO: dest is a copy of value. We could probably do this better. */
        /*       especially, as soon as we implement a clone method.        */
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));
        resize_matrix(INTERP, dest, x_size - 1, y_size - 1);
        destattr = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(dest);

        memcpy(destattr->storage, valattr->storage, sizeof(FLOATVAL)*x_size*y_size);

        cblas_daxpy(x_size*y_size, 1, selfattr->storage, 1, destattr->storage, 1);

        return dest;
    }

    METHOD resize(INTVAL new_x, INTVAL new_y) {
        resize_matrix(INTERP, SELF, new_x - 1, new_y - 1);
    }

    METHOD swap_column(INTVAL col_A, INTVAL col_b) {
    }

    METHOD swap_row(INTVAL row_a, INTVAL row_b) {
    }

    METHOD transpose() {
    }
}

