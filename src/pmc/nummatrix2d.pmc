#include "pla_matrix_types.h"
#include <cblas.h>

#define ALLOCATE_STORAGE(s) (FLOATVAL *)mem_sys_allocate_zeroed(s * sizeof (FLOATVAL))

#define SWAP_XY(a) do { \
        const INTVAL __temp_val = a->x; \
        a->x = a->y; \
        a->y = __temp_val; \
    } while(0);


/* Resize the matrix internal storage to be able to hold a point at position
   (x, y). The matrix grows but does not shrink. New spaces in the matrix
   are initialized to 0.0. Parameters x and y are the indices that are trying
   to be accessed, so we must resize the matrix to be able to accomodate those
   indices. Notice that the matrix type is zero-indexed, so the size is one
   plus the highest index that we need to access. 

   This function will not shrink the matrix, only grow it. After the call,
   the matrix will be at least large enough to hold an item at the given
   index. To shrink the matrix, use the get_block() method, or that
   algorithm. */
static void
resize_matrix(PARROT_INTERP, PMC * self, INTVAL x, INTVAL y)
{
    Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(self);
    /* Store the old values */
    const INTVAL old_x = attrs->x;
    const INTVAL old_y = attrs->y;
    FLOATVAL * old_s = attrs->storage;

    /* x and y are indices, not sizes. Resize the matrix to accomodate this
       new point without shrinking by taking the max. */
    const INTVAL new_x = INDEX_MAX(old_x, x + 1);
    const INTVAL new_y = INDEX_MAX(old_y, y + 1);
    const INTVAL newsize = new_x * new_y;
    FLOATVAL * new_s = ALLOCATE_STORAGE(newsize);

    INTVAL i, j;
    for (i = 0; i < old_x; i++) {
        for (j = 0; j < old_y; j++) {
            ITEM_XY_ROWMAJOR(new_s, new_x, new_y, i, j) =
                ITEM_XY_ROWMAJOR(old_s, old_x, old_y, i, j);
        }
    }
    attrs->storage = new_s;
    attrs->x = new_x;
    attrs->y = new_y;
    if (old_s)
        mem_sys_free(old_s);
}

static void init_from_pmc_array(PARROT_INTERP, PMC * self, INTVAL x_size, INTVAL y_size, PMC * values) {
    Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(self);
    FLOATVAL * s;
    INTVAL self_x, self_y, i, j, num = 0;
    const INTVAL init_elems = VTABLE_elements(interp, values);

    resize_matrix(interp, self, x_size - 1, y_size - 1);
    self_x = attrs->x;
    self_y = attrs->y;
    s = attrs->storage;

    for (i = 0; i < y_size; i++) {
        for (j = 0; j < x_size; j++) {
            const FLOATVAL value = VTABLE_get_number_keyed_int(interp, values, num);
            num++;
            ITEM_XY_ROWMAJOR(s, self_x, self_y, j, i) = value;
            if (num >= init_elems)
                return;
        }
    }
}

pmclass NumMatrix2D dynpmc auto_attrs does matrix {
    ATTR FLOATVAL * storage;
    ATTR INTVAL x;
    ATTR INTVAL y;
    ATTR INTVAL flags;

/*

=head1 VTABLEs

=over 4

=item* init

=cut

*/

    VTABLE void init() {
        Parrot_NumMatrix2D_attributes * const a = PARROT_NUMMATRIX2D(SELF);
        a->storage = NULL;
        a->x = 0;
        a->y = 0;
        a->flags = 0;
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void destroy() {
        Parrot_NumMatrix2D_attributes * const a = PARROT_NUMMATRIX2D(SELF);
        FLOATVAL * const s = a->storage;
        if (s)
            mem_sys_free(s);
    }

/*

=item* get_number_keyed

=item* get_integer_keyed

=item* get_string_keyed

=item* get_pmc_keyed

=cut

*/

    VTABLE FLOATVAL get_number_keyed(PMC * key) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        INTVAL x, y;
        GET_INDICES_FROM_KEY(INTERP, key, x, y);
        if (x >= x_size || y >= y_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "NumMatrix2d: indices out of bounds");
        return ITEM_XY(attrs->storage, attrs->flags, x_size, y_size, x, y);
    }

    VTABLE INTVAL get_integer_keyed(PMC * key) {
        const FLOATVAL f = VTABLE_get_number_keyed(INTERP, SELF, key);
        return (INTVAL)f;
    }

    VTABLE STRING * get_string_keyed(PMC * key) {
        const FLOATVAL f = VTABLE_get_number_keyed(INTERP, SELF, key);
        STRING * const item = Parrot_sprintf_c(INTERP, "\t%f", f);
        return item;
    }

    VTABLE PMC * get_pmc_keyed(PMC * key) {
        const FLOATVAL f = VTABLE_get_number_keyed(INTERP, SELF, key);
        PMC * const item = pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, f);
        return item;
    }

/*

=item* get_number_keyed_int

=item* get_integer_keyed_int

=item* get_string_keyed_int

=item* get_pmc_keyed_int

=cut

*/

    VTABLE FLOATVAL get_number_keyed_int(INTVAL key) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        const INTVAL total_size = attrs->x * attrs->y;
        if (key >= total_size) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                                        "NumMatrix2D: Matrix dimensions must match in add.");
        }
        return attrs->storage[key];
    }

    VTABLE INTVAL get_integer_keyed_int(INTVAL key) {
        const FLOATVAL f = VTABLE_get_number_keyed_int(INTERP, SELF, key);
        return (INTVAL)f;
    }

    VTABLE STRING * get_string_keyed_int(INTVAL key) {
        const FLOATVAL f = VTABLE_get_number_keyed_int(INTERP, SELF, key);
        STRING * const item = Parrot_sprintf_c(INTERP, "\t%f", f);
        return item;
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL key) {
        const FLOATVAL f = VTABLE_get_number_keyed_int(INTERP, SELF, key);
        PMC * const item = pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, item, f);
        return item;
    }

/*

=item* set_number_keyed

=item* set_integer_keyed

=cut

*/

    VTABLE void set_number_keyed(PMC * key, FLOATVAL value) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        INTVAL x, y, x_size = attrs->x, y_size = attrs->y;
        GET_INDICES_FROM_KEY(INTERP, key, x, y);
        if (x >= x_size || y >= y_size) {
            resize_matrix(INTERP, SELF, x, y);
            x_size = attrs->x;
            y_size = attrs->y;
        }
        ITEM_XY(attrs->storage, attrs->flags, x_size, y_size, x, y) = value;
    }

    VTABLE void set_integer_keyed(PMC * key, INTVAL value) {
        VTABLE_set_number_keyed(INTERP, SELF, key, (FLOATVAL)value);
    }

    VTABLE void set_pmc_keyed(PMC * key, PMC * value) {
        const FLOATVAL v = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_keyed(INTERP, SELF, key, v);
    }

/*

=item* get_string

=cut

*/

    VTABLE STRING *get_string() {
        INTVAL x, y;
        STRING *pstr = Parrot_str_new(INTERP, "", 0);
        STRING * const newline = Parrot_str_new(INTERP, "\n", 1);
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        FLOATVAL * const s = attrs->storage;
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;

        if (IS_TRANSPOSED(attrs->flags)) {
            for (y = 0; y < y_size; ++y) {
                for (x = 0; x < x_size; ++x) {
                    const FLOATVAL f = ITEM_XY_COLMAJOR(s, x_size, y_size, x, y);
                    STRING * const item = Parrot_sprintf_c(INTERP, "\t%f", f);
                    pstr = Parrot_str_append(INTERP, pstr, item);
                }
                pstr = Parrot_str_append(INTERP, pstr, newline);
            }
        }
        else {
            for (y = 0; y < y_size; ++y) {
                for (x = 0; x < x_size; ++x) {
                    const FLOATVAL f = ITEM_XY_ROWMAJOR(s, x_size, y_size, x, y);
                    STRING * const item = Parrot_sprintf_c(INTERP, "\t%f", f);
                    pstr = Parrot_str_append(INTERP, pstr, item);
                }
                pstr = Parrot_str_append(INTERP, pstr, newline);
            }
        }
        return pstr;
    }

    MULTI PMC *add(NumMatrix2D *value, PMC *dest) {
        int i = 0, j = 0;
        INTVAL x_size, y_size;
        Parrot_NumMatrix2D_attributes * const selfattr = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * const valattr = PARROT_NUMMATRIX2D(value);
        Parrot_NumMatrix2D_attributes * destattr;

        x_size = selfattr->x;
        y_size = selfattr->y;

        if (x_size != valattr->x || y_size != valattr->y) {
            /* XXX: Throw a better exception. */
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
              "NumMatrix2D: Matrix dimensions must match in add.");
        }

        if ((IS_TRANSPOSED(selfattr->flags) && ! IS_TRANSPOSED(valattr->flags))
            || (IS_TRANSPOSED(valattr->flags) && ! IS_TRANSPOSED(selfattr->flags))) {
            FLOATVAL *sstor = selfattr->storage,
                     *vstor = valattr->storage;
            FLOATVAL *dstor = NULL;

            dest = pmc_new(interp, VTABLE_type(interp, pmc));
            resize_matrix(interp, dest, x_size - 1, y_size - 1);
            destattr = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(dest);
            dstor = destattr->storage;

            if (IS_TRANSPOSED(selfattr->flags)) {
                for (i = 0; i < x_size; ++i) {
                    for (j = 0; j < y_size; ++j) {
                        ITEM_XY_ROWMAJOR(dstor, x_size, y_size, i, j) =
                            ITEM_XY_COLMAJOR(sstor, x_size, y_size, i, j)
                            + ITEM_XY_ROWMAJOR(vstor, x_size, y_size, i, j);
                    }
                }
            }
            else {
                for (i = 0; i < x_size; ++i) {
                    for (j = 0; j < y_size; ++j) {
                        ITEM_XY_ROWMAJOR(dstor, x_size, y_size, i, j) =
                            ITEM_XY_ROWMAJOR(sstor, x_size, y_size, i, j)
                            + ITEM_XY_COLMAJOR(vstor, x_size, y_size, i, j);
                    }
                }
            }
        }
        else {
            dest = VTABLE_clone(INTERP, value);
            destattr = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(dest);

            cblas_daxpy(x_size*y_size, 1, selfattr->storage, 1, destattr->storage, 1);
        }

        return dest;
    }

    MULTI PMC *add(Float *value, PMC *dest) {
        const FLOATVAL v = VTABLE_get_number(INTERP, value);
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * dest_attrs;
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        FLOATVAL * const s = attrs->storage;
        FLOATVAL * dest_s;
        INTVAL i, j;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        resize_matrix(INTERP, dest, x_size - 1, y_size - 1);
        dest_attrs = PARROT_NUMMATRIX2D(dest);
        dest_s = dest_attrs->storage;

        /* TODO: See if BLAS has a routine to do this */
        for (j = 0; j < y_size; j++) {
            for (i = 0; i < x_size; i++) {
                ITEM_XY_ROWMAJOR(dest_s, x_size, y_size, i, j) =
                    ITEM_XY_ROWMAJOR(s, x_size, y_size, i, j) + v;
            }
        }
        return dest;
    }

    MULTI PMC *multiply(NumMatrix2D *value, PMC *dest) {
        INTVAL x_size = 0, y_size = 0, sflags = 0, vflags = 0;

        Parrot_NumMatrix2D_attributes * const selfattr = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * const valattr = PARROT_NUMMATRIX2D(value);
        Parrot_NumMatrix2D_attributes * destattr = NULL;

        x_size = selfattr->x;
        y_size = valattr->y;
        sflags = selfattr->flags;
        vflags = valattr->flags;

        if (selfattr->y != valattr->x) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
              "NumMatrix2D:");
        }

        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));
        resize_matrix(INTERP, dest, x_size - 1, y_size - 1);
        destattr = (Parrot_NumMatrix2D_attributes *) PARROT_NUMMATRIX2D(dest);

        if (IS_TINY(sflags) || (IS_GENERAL(sflags) && IS_GENERAL(vflags))) {
            cblas_dgemm(CblasRowMajor,
                IS_TRANSPOSED_BLAS(selfattr->flags),
                IS_TRANSPOSED_BLAS(valattr->flags),
                x_size,
                selfattr->y,
                y_size,
                1.,
                selfattr->storage,
                x_size,
                valattr->storage,
                y_size,
                0.,
                destattr->storage,
                x_size
            );
        }
        else if (IS_SYMMETRIC(sflags)) {
            cblas_dsymm(
                CblasRowMajor,
                (IS_TRANSPOSED(vflags) ? CblasRight : CblasLeft),
                CblasUpper,
                x_size,
                y_size,
                1.,
                selfattr->storage,
                x_size,
                valattr->storage,
                valattr->x,
                1.,
                destattr->storage,
                x_size
            );

            if (IS_TRANSPOSED(vflags)) {
                /* TODO: Transpose matrix */
            }
        }
        else if (IS_SYMMETRIC(vflags)) {
            cblas_dsymm(
                CblasRowMajor,
                (IS_TRANSPOSED(sflags) ? CblasLeft : CblasRight),
                CblasUpper,
                x_size,
                y_size,
                1.,
                valattr->storage,
                valattr->x,
                selfattr->storage,
                selfattr->x,
                1.,
                destattr->storage,
                x_size
            );

            if (IS_TRANSPOSED(sflags)) {
                /* TODO: Transpose matrix */
            }
        }
/*        else if (IS_TRIANGLE(sflags)) {
            cblas_dtrmm(
                CblasRowMajor,
                CblasLeft,
                (IS_LTRIANGLE(sflags) ? CblasLower : CblasUpper),
                x_size,
                y_size,
                1.,
                selfattr->storage,
                selfattr->x,
                valattr->storage,
                valattr->x,
                0.,
                destattr->storage,
                x_size
            );

        }
        else if (IS_TRIANGLE(vflags)) {
            cblas_dtrmm(
                CblasRowMajor,
                CblasRight,
                (IS_LTRIANGLE(vflags) ? CblasLower : CblasUpper),

        }
*/
        else {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                "parrot-linear-algebra: Method multiply not implemented for "
                "this combination of flags.");
        }

        destattr->flags = sflags & vflags;
        return dest;
    }

    MULTI PMC *multiply(Float *value, PMC *dest) {
        const FLOATVAL v = VTABLE_get_number(INTERP, value);
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * dest_attrs;
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        FLOATVAL * const s = attrs->storage;
        FLOATVAL * dest_s;
        INTVAL i, j;

        dest = pmc_new(INTERP, SELF->vtable->base_type);
        resize_matrix(INTERP, dest, x_size - 1, y_size - 1);
        dest_attrs = PARROT_NUMMATRIX2D(dest);
        dest_s = dest_attrs->storage;

        /* TODO: See if BLAS has a routine to do this */
        for (j = 0; j < y_size; j++) {
            for (i = 0; i < x_size; i++) {
                ITEM_XY_ROWMAJOR(dest_s, x_size, y_size, i, j) =
                    ITEM_XY_ROWMAJOR(s, x_size, y_size, i, j) * v;
            }
        }
        return dest;
    }

    VTABLE PMC * get_attr_str(STRING * idx) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "X"))) {
            PMC * const x = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, x, attrs->x);
            return x;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "Y"))) {
            PMC * const y = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, y, attrs->y);
            return y;
        }
        else if (Parrot_str_equal(INTERP, idx, CONST_STRING(INTERP, "size"))) {
            PMC * const size = pmc_new(INTERP, enum_class_Integer);
            VTABLE_set_integer_native(INTERP, size, attrs->y * attrs->x);
            return size;
        }
        return PMCNULL;
    }

    VTABLE PMC * clone() {
        PMC * const c = pmc_new(INTERP, SELF->vtable->base_type);
        Parrot_NumMatrix2D_attributes * const old_atts = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * const new_atts = PARROT_NUMMATRIX2D(c);
        INTVAL x, y;
        INTVAL const x_size = old_atts->x;
        INTVAL const y_size = old_atts->y;
        INTVAL const newsize = x_size * y_size;
        FLOATVAL * const old_s = old_atts->storage;
        FLOATVAL * const new_s = ALLOCATE_STORAGE(newsize);
        for (x = 0; x < x_size; ++x) {
            for (y = 0; y < y_size; ++y) {
                ITEM_XY_ROWMAJOR(new_s, x_size, y_size, x, y) =
                    ITEM_XY_ROWMAJOR(old_s, x_size, y_size, x, y);
            }
        }
        new_atts->storage = new_s;
        new_atts->flags = old_atts->flags;
        new_atts->x = x_size;
        new_atts->y = y_size;
        return c;
    }

    VTABLE INTVAL is_equal(PMC * other) {
        if (other->vtable->base_type == SELF->vtable->base_type) {
            Parrot_NumMatrix2D_attributes * const self_attrs = PARROT_NUMMATRIX2D(SELF);
            Parrot_NumMatrix2D_attributes * const other_attrs = PARROT_NUMMATRIX2D(other);
            const INTVAL self_x = self_attrs->x;
            const INTVAL self_y = self_attrs->y;
            const INTVAL self_flags = self_attrs->flags;
            const INTVAL other_x = other_attrs->x;
            const INTVAL other_y = other_attrs->y;
            const INTVAL other_flags = other_attrs->flags;
            FLOATVAL * const self_s = self_attrs->storage;
            FLOATVAL * const other_s = other_attrs->storage;
            INTVAL x, y;

            if (self_x != other_x || self_y != other_y)
                return 0;

            for (y = 0; y < self_y; y++) {
                for (x = 0; x < self_x; x++) {
                    const FLOATVAL self_value =
                        ITEM_XY(self_s, self_flags, self_x, self_y, x, y);
                    const FLOATVAL other_value =
                        ITEM_XY(other_s, other_flags, other_x, other_y, x, y);
                    if (self_value != other_value)
                        return 0;
                }
            }
            return 1;
        }
        return 0;
    }


/*

=back

=head1 METHODS

=over 4

*/
/*

=item resize()

=cut

*/

    METHOD resize(INTVAL new_x, INTVAL new_y) {
        resize_matrix(INTERP, SELF, new_x - 1, new_y - 1);
    }

/*

=item fill()

Fill the matrix with a single value. if sizes are provided, fill to those
sizes, growing the matrix if needed.

=cut

*/

    METHOD fill(FLOATVAL value,
                INTVAL x_size :optional, INTVAL has_x_size :opt_flag,
                INTVAL y_size :optional, INTVAL has_y_size :opt_flag
               ) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        FLOATVAL * s  = attrs->storage;
        INTVAL const curr_x_size = attrs->x;
        INTVAL const curr_y_size = attrs->y;
        INTVAL x, y;

        if (!has_x_size)
            x_size = curr_x_size;
        if (!has_y_size)
            y_size = curr_y_size;

        if ((has_x_size && x_size > curr_x_size) ||
            (has_y_size && y_size > curr_y_size)) {
            resize_matrix(INTERP, SELF, x_size - 1, y_size - 1);
            s = attrs->storage;
        }

        for (x = 0; x < x_size; ++x) {
            for (y = 0; y < y_size; ++y) {
                ITEM_XY_ROWMAJOR(s, x_size, y_size, x, y) = value;
            }
        }
    }

/*

=item transpose()

Transposes the matrix.

=cut

*/

    METHOD transpose() {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        INTVAL tmp = 0;
        INTVAL transposed = IS_TRANSPOSED(attrs->flags);

        SWAP_XY(attrs);

        if (transposed)
            attrs->flags -= FLAG_TRANSPOSED;
        else
            attrs->flags += FLAG_TRANSPOSED;
        transposed = !transposed;
        RETURN(INTVAL transposed);
    }

/*

=item mem_transpose()

Transposes the actual data storage of the matrix. More expensive up-front
than the transpose() method.

=cut

*/

    METHOD mem_transpose() {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        const INTVAL newsize = x_size * y_size;
        FLOATVAL * new_s = ALLOCATE_STORAGE(newsize);
        FLOATVAL * old_s = attrs->storage;

        INTVAL i, j;
        for (i = 0; i < x_size; i++) {
            for (j = 0; j < y_size; j++) {
                ITEM_XY_ROWMAJOR(new_s, y_size, x_size, j, i) =
                    ITEM_XY_ROWMAJOR(old_s, x_size, y_size, i, j);
            }
        }
        attrs->storage = new_s;
        SWAP_XY(attrs);
        if (old_s)
            free(old_s);
    }

/*

=item iterate_function_inplace()

Calls a function for every element in the array, replacing the current
value with the return value of the called function.

=cut

*/

    METHOD iterate_function_inplace(PMC * func, PMC * args :slurpy) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        const INTVAL newsize = x_size * y_size;
        FLOATVAL * old_s = attrs->storage;
        FLOATVAL * new_s = ALLOCATE_STORAGE(newsize);
        INTVAL i, j;

        if (newsize == 0 || old_s == NULL)
            RETURN();

        for (j = 0; j < y_size; j++) {
            for (i = 0; i < x_size; i++) {
                const FLOATVAL value = ITEM_XY_ROWMAJOR(old_s, x_size, y_size, i, j);
                FLOATVAL result = 0.0;
                Parrot_ext_call(INTERP, func, "PNIIPf->N", SELF, value, i, j, args, &result);
                ITEM_XY_ROWMAJOR(new_s, x_size, y_size, i, j) = result;
            }
        }
        attrs->storage = new_s;
        if (old_s)
            free(old_s);
    }

    METHOD iterate_function_external(PMC * func, PMC * args :slurpy) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        PMC * const new_matrix = pmc_new(INTERP, SELF->vtable->base_type);
        Parrot_NumMatrix2D_attributes * new_attrs;
        const INTVAL x_size = attrs->x;
        const INTVAL y_size = attrs->y;
        const INTVAL newsize = x_size * y_size;
        FLOATVAL * const self_s = attrs->storage;
        FLOATVAL * new_s;
        INTVAL i, j;

        if (newsize == 0 || self_s == NULL)
            RETURN(PMC * new_matrix);

        resize_matrix(INTERP, new_matrix, x_size - 1, y_size - 1);
        new_attrs = PARROT_NUMMATRIX2D(new_matrix);
        new_s = new_attrs->storage;

        for (j = 0; j < y_size; j++) {
            for (i = 0; i < x_size; i++) {
                FLOATVAL value = ITEM_XY_ROWMAJOR(self_s, x_size, y_size, i, j);
                FLOATVAL result = 0.0;
                Parrot_ext_call(INTERP, func, "PNIIPf->N", SELF, value, i, j, args, &result);
                ITEM_XY_ROWMAJOR(new_s, x_size, y_size, i, j) = result;
            }
        }
        RETURN(PMC * new_matrix);
    }

/*

=item instantiate_from_array()

Instantiate a new matrix from a linear array, filling each row with data
in order.

=cut

*/

    METHOD initialize_from_array(INTVAL x_size, INTVAL y_size, PMC *values) {
        init_from_pmc_array(INTERP, SELF, x_size, y_size, values);
    }

    METHOD initialize_from_args(INTVAL x_size, INTVAL y_size, PMC *values :slurpy) {
        init_from_pmc_array(INTERP, SELF, x_size, y_size, values);
    }

    METHOD get_block(INTVAL x_idx, INTVAL y_idx, INTVAL x_size, INTVAL y_size) {
        Parrot_NumMatrix2D_attributes * const attrs = PARROT_NUMMATRIX2D(SELF);
        FLOATVAL * const s = attrs->storage;
        const INTVAL x = attrs->x;
        const INTVAL y = attrs->y;
        INTVAL i, j;

        if ((x < x_idx + x_size) || (y < y_idx + y_size))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "NumMatrix2D: block boundaries exceed matrix size");
        else {
            PMC * const new_matrix = pmc_new(INTERP, SELF->vtable->base_type);
            Parrot_NumMatrix2D_attributes * const new_attrs = PARROT_NUMMATRIX2D(new_matrix);
            FLOATVAL * new_s;
            resize_matrix(INTERP, new_matrix, x_size - 1, y_size - 1);
            new_s = new_attrs->storage;
            for (i = 0; i < y_size; i++) {
                for (j = 0; j < x_size; j++) {
                    ITEM_XY_ROWMAJOR(new_s, x_size, y_size, j, i) =
                        ITEM_XY_ROWMAJOR(s, x, y, j + x_idx, i + y_idx);
                }
            }
            RETURN(PMC * new_matrix);
        }
    }

    METHOD set_block(INTVAL x_idx, INTVAL y_idx, PMC * blck) {
        Parrot_NumMatrix2D_attributes * const self_attrs = PARROT_NUMMATRIX2D(SELF);
        Parrot_NumMatrix2D_attributes * const blck_attrs = PARROT_NUMMATRIX2D(blck);
        FLOATVAL * self_s = self_attrs->storage;
        FLOATVAL * const blck_s = blck_attrs->storage;
        INTVAL self_x = self_attrs->x;
        INTVAL self_y = self_attrs->y;
        const INTVAL blck_x = blck_attrs->x;
        const INTVAL blck_y = blck_attrs->y;
        INTVAL i, j;

        if (blck_x + x_idx > self_x || blck_y + y_idx > self_y) {
            resize_matrix(INTERP, SELF, blck_x + x_idx - 1, blck_y + y_idx - 1);
            self_s = self_attrs->storage;
            self_x = self_attrs->x;
            self_y = self_attrs->y;
        }
        for (i = 0; i < blck_y; i++) {
            for (j = 0; j < blck_x; j++) {
                ITEM_XY_ROWMAJOR(self_s, self_x, self_y, j + x_idx, i + y_idx) =
                    ITEM_XY_ROWMAJOR(blck_s, blck_x, blck_y, j, i);
            }
        }
    }

/*

=back

=end

*/
}

