---
layout: poddocs
title: ComplexMatrix2D
stylesheet: stylesheets/poddocs.css
---

<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>src/pmc/complexmatrix2d.pmc</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
{{ page.stylesheet }}
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#complexmatrix2d">ComplexMatrix2D</a></li>
	<ul>

		<li><a href="#description">Description</a></li>
	</ul>

	<li><a href="#vtables">VTABLEs</a></li>
	<ul>

		<li><a href="#system_vtables">System VTABLEs</a></li>
		<li><a href="#keyed_lookup_vtables">Keyed lookup VTABLEs</a></li>
		<li><a href="#integer_keyed_lookup_vtables">Integer-Keyed Lookup VTABLES</a></li>
		<li><a href="#keyed_setter_vtables">Keyed Setter VTABLES</a></li>
		<li><a href="#integer_keyed_setter_vtables">Integer-Keyed Setter VTABLEs</a></li>
		<li><a href="#miscellaneous_vtables">Miscellaneous VTABLEs</a></li>
		<li><a href="#serialization_deserialization_vtables">Serialization/Deserialization VTABLEs</a></li>
		<li><a href="#addition_vtables">Addition VTABLEs</a></li>
		<li><a href="#in_place_addition_vtables">In-Place Addition VTABLEs</a></li>
		<li><a href="#subtraction_vtables">Subtraction VTABLEs</a></li>
		<li><a href="#in_place_subtraction_vtables">In-Place Subtraction VTABLEs</a></li>
		<li><a href="#multiplication_vtables">Multiplication VTABLEs</a></li>
		<li><a href="#in_place_multiplication_vtables">In-Place Multiplication VTABLEs</a></li>
	</ul>

	<li><a href="#methods">METHODS</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="complexmatrix2d">ComplexMatrix2D</a></h1>
<p>
</p>
<h2><a name="description">Description</a></h2>
<p>ComplexMatrix2D is a 2-dimensional complex-valued matrix type for the Parrot
Virtual Machine. It supports a variety of element-wise and matrix operations,
including bindings to the BLAS and LAPACK libraries.</p>
<p>
</p>
<hr />
<h1><a name="vtables">VTABLEs</a></h1>
<p>
</p>
<h2><a name="system_vtables">System VTABLEs</a></h2>
<ul>
<li><strong><a name="init" class="item">init</a></strong>

<p>Initialize the new PMC</p>
</li>
<li><strong><a name="destroy" class="item">destroy</a></strong>

<p>Destroy the PMC and free all associated memory</p>
</li>
</ul>
<p>
</p>
<h2><a name="keyed_lookup_vtables">Keyed lookup VTABLEs</a></h2>
<p>In each of these cases, the specified Key PMC must have exactly two elements
to specify a location in the matrix.</p>
<p>Attempting to retrieve a value outside the boundaries of the matrix will throw
an OUT_OF_BOUNDS exception.</p>
<ul>
<li><strong><a name="get_number_keyed" class="item">get_number_keyed</a></strong>

<p>Get a floating point value at the location specified by the key.</p>
<p>The floating point value is calculated as the magnitude of the complex value
at the point in the matrix.</p>
</li>
<li><strong><a name="get_integer_keyed" class="item">get_integer_keyed</a></strong>

<p>Get an integer value at the location specified by the key.</p>
<p>The integer value is the magnitude of the complex value at the specified
location, cast from a floating point to an integer value.</p>
</li>
<li><strong><a name="get_string_keyed" class="item">get_string_keyed</a></strong>

<p>Get the string representation of the complex value at the point specified by
the key.</p>
<p>The returned string has the same format as is used by the Parrot built-in
Complex PMC type.</p>
</li>
<li><strong><a name="get_pmc_keyed" class="item">get_pmc_keyed</a></strong>

<p>Get a Complex PMC from the point specified by the key.</p>
</li>
</ul>
<p>
</p>
<h2><a name="integer_keyed_lookup_vtables">Integer-Keyed Lookup VTABLES</a></h2>
<p>These VTABLEs treat the matrix, which is a contiguous region in memory, as a
linear array of values. The matrix data is stored by rows.</p>
<p>These routines are used for low-level access. Attempting to access a value
outside the bounds of the matrix will throw an OUT_OF_BOUNDS exception.</p>
<ul>
<li><strong><a name="get_number_keyed_int" class="item">get_number_keyed_int</a></strong>

<p>Get a floating point number, the magnitude of the complex value, at the
specified location in the array</p>
</li>
<li><strong><a name="get_integer_keyed_int" class="item">get_integer_keyed_int</a></strong>

<p>Get an integer, cast from the magnitude of the complex value, at the specified
location in the array</p>
</li>
<li><strong><a name="get_string_keyed_int" class="item">get_string_keyed_int</a></strong>

<p>Get a string representation of the value at the specified point. Stringification
is done the same as Parrot's Complex PMC type.</p>
</li>
<li><strong><a name="get_pmc_keyed_int" class="item">get_pmc_keyed_int</a></strong>

<p>Get a Complex PMC from the value at the specified point.</p>
</li>
</ul>
<p>
</p>
<h2><a name="keyed_setter_vtables">Keyed Setter VTABLES</a></h2>
<p>These VTABLEs insert new values into the matrix at a point specified by the
Key PMC. The Key PMC must have exactly two elements. If the matrix is not large
enough to accomodate the specified location, it will be grown with zero-padding
so that it is at least large enough to hold the specified point and all existing
data.</p>
<ul>
<li><strong><a name="set_pmc_keyed" class="item">set_pmc_keyed</a></strong>

<p>Set the value at the specified location to the complex value represented by the
given PMC. Different PMC types have different behaviors in this operation.</p>
</li>
<li><strong><a name="set_number_keyed" class="item">set_number_keyed</a></strong>

<p>Set the value at the specified location to have a real value given by the
number, and 0 for the complex value.</p>
</li>
<li><strong><a name="set_string_keyed" class="item">set_string_keyed</a></strong>

<p>Set the value at the specified location to the value represented by the string.
The string is parsed by creating a temporary Complex PMC type, so all the same
rules for that type apply to the input string format.</p>
</li>
<li><strong><a name="set_integer_keyed" class="item">set_integer_keyed</a></strong>

<p>Set the value at the specified location to have a real value given by the
integer, and 0 for the complex value.</p>
</li>
</ul>
<p>
</p>
<h2><a name="integer_keyed_setter_vtables">Integer-Keyed Setter VTABLEs</a></h2>
<p>These VTABLEs treat the matrix as a linear array in memory and allow fast
lookup based on the integer offset of values in the array. These are low-level
routines and are not intended for general use.</p>
<p>Unlike the PMC-keyed VTABLEs, these routines will not automatically grow the
matrix if an index is provided which is outside the boundaries of the matrix.
In that case, an OUT_OF_BOUNDS exception will be thrown.</p>
<ul>
<li><strong><a name="set_pmc_keyed_int" class="item">set_pmc_keyed_int</a></strong>

<p>Set a PMC at the specified location. The rules for extracting a complex value
out of the input PMC are the same as used for <a href="#set_pmc_keyed"><code>set_pmc_keyed()</code></a></p>
</li>
<li><strong><a name="set_number_keyed_int" class="item">set_number_keyed_int</a></strong>

<p>Set the complex value at the specified location to the given real value. The
complex part of the value will be 0.</p>
</li>
<li><strong><a name="set_integer_keyed_int" class="item">set_integer_keyed_int</a></strong>

<p>Set the complex value at the specified location to the given real value. The
complex part of the value will be 0</p>
</li>
<li><strong><a name="set_string_keyed_int" class="item">set_string_keyed_int</a></strong>

<p>Convert the string to a Complex PMC, and set that at the specified location.</p>
</li>
</ul>
<p>
</p>
<h2><a name="miscellaneous_vtables">Miscellaneous VTABLEs</a></h2>
<ul>
<li><strong><a name="get_string" class="item">get_string</a></strong>

<p>Get a string representation of the matrix, suitable for printing to the console</p>
</li>
<li><strong><a name="get_attr_string" class="item">get_attr_string</a></strong>

<p>Get a named attribute. The name can be one of &quot;rows&quot;, &quot;cols&quot;, or &quot;size&quot;.</p>
</li>
<li><strong><a name="clone" class="item">clone</a></strong>

<p>Clone the matrix</p>
</li>
<li><strong><a name="is_equal" class="item">is_equal</a></strong>

<p>Determine if two matrices are equal in size and composition.</p>
</li>
</ul>
<p>
</p>
<h2><a name="serialization_deserialization_vtables">Serialization/Deserialization VTABLEs</a></h2>
<ul>
<li><strong><a name="freeze" class="item">freeze</a></strong>

<p>Freeze the PMC for serialization to a string suitable for long-term storage in
a file.</p>
</li>
<li><strong><a name="thaw" class="item">thaw</a></strong>

<p>Thaw a serialized PMC</p>
</li>
</ul>
<p>
</p>
<h2><a name="addition_vtables">Addition VTABLEs</a></h2>
<ul>
<li><strong><a name="add" class="item">add(ComplexMatrix2D)</a></strong>

<p>Add two matrices together, element-by-element.</p>
</li>
<li><strong>add(Complex)</strong>

<p>Add a complex value to each element of the matrix</p>
</li>
<li><strong>add(DEFAULT)</strong>

<p>Take the number representation of the argument PMC and add it to every element
in the matrix.</p>
</li>
<li><strong><a name="add_float" class="item">add_float</a></strong>

<p>Add the float value to every element in the matrix.</p>
</li>
<li><strong><a name="add_int" class="item">add_int</a></strong>

<p>Add the integer value to every element in the matrix.</p>
</li>
</ul>
<p>
</p>
<h2><a name="in_place_addition_vtables">In-Place Addition VTABLEs</a></h2>
<ul>
<li><strong><a name="i_add" class="item">i_add(ComplexMatrix2D)</a></strong>

<p>Add a matrix into SELF</p>
</li>
<li><strong>i_add(Complex)</strong>

<p>Add a Complex value to every element of SELF</p>
</li>
<li><strong>i_add(DEFAULT)</strong>

<p>Add the numeric value of the given PMC to every element of SELF</p>
</li>
<li><strong><a name="i_add_int" class="item">i_add_int</a></strong>

<p>Add the integer value to every element of SELF</p>
</li>
<li><strong><a name="i_add_float" class="item">i_add_float</a></strong>

<p>Add the floating-point value to every element of SELF</p>
</li>
</ul>
<p>
</p>
<h2><a name="subtraction_vtables">Subtraction VTABLEs</a></h2>
<ul>
<li><strong><a name="subtract" class="item">subtract(ComplexMatrix2D)</a></strong>

<p>Perform the matrix operation</p>
<pre>
    C = SELF - A</pre>
</li>
<li><strong>subtract(Complex)</strong>

<p>Subtract a complex value from each element of the matrix</p>
</li>
<li><strong>subtract(DEFAULT)</strong>

<p>Take the number representation of the argument PMC and subtract it from every
element in the matrix.</p>
</li>
<li><strong><a name="subtract_float" class="item">subtract_float</a></strong>

<p>Subtract the float value from every element in the matrix.</p>
</li>
<li><strong><a name="subtract_int" class="item">subtract_int</a></strong>

<p>Subtract the integer value from every element in the matrix.</p>
</li>
</ul>
<p>
</p>
<h2><a name="in_place_subtraction_vtables">In-Place Subtraction VTABLEs</a></h2>
<ul>
<li><strong><a name="i_subtract" class="item">i_subtract(ComplexMatrix2D)</a></strong>

<p>Perform the matrix operation</p>
<pre>
    SELF = SELF - A</pre>
</li>
<li><strong>i_subtract(Complex)</strong>

<p>Substract a complex value from each element of the matrix</p>
</li>
<li><strong>i_subtract(DEFAULT)</strong>

<p>Subtract the numeric value of the PMC from the real part of each element in the
matrix</p>
</li>
<li><strong><a name="i_subtract_int" class="item">i_subtract_int</a></strong>

<p>Subtract the integer value from the real part of each element in the matrix</p>
</li>
<li><strong><a name="i_subtract_float" class="item">i_subtract_float</a></strong>

<p>Subtract the floating point value from the real part of each element in the
matrix</p>
</li>
</ul>
<p>
</p>
<h2><a name="multiplication_vtables">Multiplication VTABLEs</a></h2>
<ul>
<li><strong><a name="multiply" class="item">multiply(ComplexMatrix2D)</a></strong>

<p>Perform the matrix operation</p>
<pre>
    C = SELF × A</pre>
</li>
<li><strong>multiply(Complex)</strong>

<p>Multiply each element in the matrix by the complex value</p>
</li>
<li><strong>multiply(DEFAULT)</strong>

<p>Multiply each element in the matrix by the numeric value of the PMC</p>
</li>
<li><strong><a name="multiply_int" class="item">multiply_int</a></strong>

<p>Multiply each element in the matrix by the integer</p>
</li>
<li><strong><a name="multiply_float" class="item">multiply_float</a></strong>

<p>Multiply each element in the matrix by the floating point number</p>
</li>
</ul>
<p>
</p>
<h2><a name="in_place_multiplication_vtables">In-Place Multiplication VTABLEs</a></h2>
<ul>
<li><strong><a name="i_multiply" class="item">i_multiply(ComplexMatrix2D)</a></strong>

<p>Perform the matrix operation</p>
<pre>
    SELF = SELF × A</pre>
</li>
<li><strong>i_multiply(Complex)</strong>

<p>Multiply every element in SELF by the complex value</p>
</li>
<li><strong>i_multiply(DEFAULT)</strong>

<p>Multiply every element in SELF by the numeric value of the PMC</p>
</li>
<li><strong><a name="i_multiply_int" class="item">i_multiply_int</a></strong>

<p>Multiply every element in SELF by the integer</p>
</li>
<li><strong><a name="i_multiply_float" class="item">i_multiply_float</a></strong>

<p>Multiply every element in SELF by the floating point number</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<ul>
<li><strong><a name="resize" class="item"><code>resize()</code></a></strong>

<p>Resize the matrix to include at least the specified number of rows and columns.</p>
<p>Resizing the matrix never causes the matrix to shrink. If you need a subset of
the matrix, use get_block instead.</p>
</li>
<li><strong><a name="fill" class="item"><code>fill()</code></a></strong>

<p>Fill the matrix with a single value. if sizes are provided, fill to those
sizes, growing the matrix if needed. Elements outside the specified area are
unaffected. Calling <a href="#fill"><code>fill()</code></a> never causes the matrix to shrink.</p>
</li>
<li><strong><a name="item_at" class="item"><code>item_at()</code></a></strong>

<p>Return a single Complex PMC from the item at the specified coordinates</p>
</li>
<li><strong><a name="transpose" class="item"><code>transpose()</code></a></strong>

<p>Transposes the matrix lazily. This operation is O(1). Some operations, such as
mathematical operations do not work on a matrix which has been lazily
transposed, so those operations will force the matrix memory to be eagerly
transposed.</p>
</li>
<li><strong><a name="mem_transpose" class="item"><code>mem_transpose()</code></a></strong>

<p>Transposes the actual data storage of the matrix. More expensive O(n) up-front
than the <a href="#transpose"><code>transpose()</code></a> method, but the resulting memory structure is more suitable
for use in certain mathematical operations.</p>
</li>
<li><strong><a name="conjugate" class="item">conjugate</a></strong>

<p>Convert the matrix to the complex conjugate of itself.</p>
</li>
<li><strong><a name="iterate_function_inplace" class="item"><code>iterate_function_inplace()</code></a></strong>

<p>Calls a function for every element in the matrix, replacing the current
value with the return value of the called function.</p>
</li>
<li><strong><a name="iterate_function_external" class="item"><code>iterate_function_external()</code></a></strong>

<p>Calls a function for every element in the matrix, creating a new matrix with
the returned values of the called function.</p>
</li>
<li><strong><a name="initialize_from_array" class="item">initialize_from_array</a></strong>

<p>Initialize the matrix using a list of values from an array.</p>
</li>
<li><strong><a name="initialize_from_args" class="item">initialize_from_args</a></strong>

<p>Initialize the matrix using values from a variadic (slurpy) argument list.</p>
</li>
<li><strong><a name="get_block" class="item">get_block</a></strong>

<p>Get a specified sub-block of the matrix. If the bounds of the sub-block are
outside the bounds of the matrix, an OUT_OF_BOUNDS exception is thrown.</p>
</li>
<li><strong><a name="set_block" class="item">set_block</a></strong>

<p>Set a block in the matrix, growing it if needed.</p>
</li>
<li><strong><a name="gemm" class="item">gemm</a></strong>

<p>Calculates the matrix equation:</p>
<pre>
    Z = aAB + bC</pre>
<p>The matrices must all be ComplexMatrix2D, or must be convertable to it. The
matrix SELF is not used in the calculation, but the result matrix will have the
same type as SELF.</p>
</li>
<li><strong><a name="row_combine" class="item">row_combine(srcidx, destidx, gain)</a></strong>

<p>add a multiple of the source row to the destination row. If either of the row
indices are outside the bounds of the matrix, an OUT_OF_BOUNDS exception is
thrown.</p>
</li>
<li><strong><a name="row_scale" class="item">row_scale(idx, gain)</a></strong>

<p>Multiply all elements in the row by a gain factor. If the row index is outside
the bounds of the matrix and OUT_OF_BOUNDS exception is thrown.</p>
</li>
<li><strong><a name="row_swap" class="item">row_swap(idx_a, idx_b)</a></strong>

<p>Swap two rows. If either of the row indices are outside the bounds of the
matrix, an OUT_OF_BOUNDS exception is thrown.</p>
</li>
<li><strong><a name="convert_to_number_matrix" class="item">convert_to_number_matrix</a></strong>

<p>Get a NumMatrix2D from the current matrix. If the matrix is already a
NumMatrix2D, return a clone.</p>
</li>
<li><strong><a name="convert_to_complex_matrix" class="item">convert_to_complex_matrix</a></strong>

<p>Get a ComplexMatrix2D from the current matrix. If the matrix is already a
ComplexMatrix2D, return a clone.</p>
</li>
<li><strong><a name="convert_to_pmc_matrix" class="item">convert_to_pmc_matrix</a></strong>

<p>Get a PMCMatrix2D from the current matrix. If the matrix is already a
PMCMatrix2D, return a clone.</p>
</li>
</ul>

</body>

</html>
